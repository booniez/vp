---
title: 抽象类
date: 2024-04-18 17:36:08
---

## 概述
- 抽象方法： 当我们将共性的行为（方法）抽取到父类之后，发现该方法的视线逻辑不能在父类中确定的时候，这个方法就可以定义为**抽象方法**
- 抽象类：**如果一个类中存在抽象方法**，那么这个类必须声明为 抽象类

## 注意事项
- 抽象类不能创建对象
  - 虽然不能直接创建对象，但是可以创建 匿名内部类
	:::tip
	在Java中，可以使用匿名内部类来创建一个抽象类的实例对象，这是一种特例。即使抽象类本身不能直接实例化，匿名内部类允许我们在声明的同时提供抽象方法的具体实现，进而创建出该抽象类的一个具体实例。因此，可以说匿名内部类创建的对象是抽象类的实例对象。
	下面是一个以 Animal 为例的匿名内部类创建实例的示例：
	
	
	```
		abstract class Animal {
			public abstract void makeSound();
		}

		public class Test {
			public static void main(String[] args) {
				// 使用匿名内部类创建 Animal 类的实例对象
				Animal a = new Animal() {
					@Override
					public void makeSound() {
						System.out.println("Some sound");
					}
				};
	
				a.makeSound(); // 输出：Some sound
			}
		}

	```

在这个例子中，我们创建了 Animal 类的一个匿名内部类，并提供了 makeSound 方法的具体实现，然后我们用这个匿名内部类创建了一个 Animal 类型的对象 a。这个对象 a 的确是 Animal 类的一个实例，它具备了 Animal 类的所有属性和行为，并且能够调用 makeSound 方法。
需要注意的是，即便这种方式可以创建抽象类的实例，但这样创建的匿名内部类对象没有一个与之关联的具体的类名，因此它只能在被定义时被使用。如果要多次创建相同行为的实例，通常会定义一个具体的子类来继承抽象类。匿名内部类更多地适用于那些仅需要一次性使用的实例化场景。
	:::

- 抽象类还是有构造方法的
	- 抽象类的子类，会默认调用父类的构造方法，如果父类没有构造方法，不就挂了！
- 抽象类的子类
	- 必须重写父类中所有的抽象方法
	- 可以将自己变成抽象类
- 抽象类里面的方法，既可以是抽象方法也可以不是
- 抽象类中可以没有抽象方法
- 抽象方法能不能重写？
	- 抽象类的继承类要实现抽象方法，如果不想实现，就把自己变成抽象类，让继承类去实现
	
## final 关键字
- 修饰类 则是最终类，不能被继承类。
- 修饰方法 则是最终方法，不能被重写
- 修饰变量 则表示常量，不能被二次赋值
	- 必须在构造方法结束之前完成赋值，通常定义的时候直接赋值

